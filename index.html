<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Melodic Feed</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Billabong&display=swap');
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      margin: 0; padding: 0; background: #fafafa; color: #333;
    }
    header {
      font-family: 'Billabong', cursive;
      font-size: 2rem; padding: 1rem; text-align: center; background: white;
      border-bottom: 1px solid #ddd; position: sticky; top: 0; z-index: 10;
    }
    .feed { max-width: 600px; margin: 1rem auto; }
    .post {
      background: white; margin-bottom: 1rem; border: 1px solid #ddd;
      border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .post img { width: 100%; display: block; }
    .actions { display: flex; justify-content: space-around; padding: 0.5rem; }
    .action-btn { border: none; background: none; cursor: pointer; font-size: 1.2rem; }
  </style>
</head>
<body>
  <header>Melodic Feed</header>
  <div class="feed" id="feed"></div>

  <script>
    // === Audio setup ===
    let audioContext;
    let masterGain;
    let currentWaveform = "sine"; // default waveform
    const voices = {}; // active touches ‚Üí {osc, gain, filter}

    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.gain.setValueAtTime(0.8, audioContext.currentTime);
        masterGain.connect(audioContext.destination);
      }
    }

    // minor pentatonic steps
    const pentatonic = [0, 3, 5, 7, 10];
    function yToFreq(y) {
      const height = window.innerHeight;
      const norm = 1 - (y / height);
      const min = 40, max = 1000;
      const scaled = norm * 30; // up to ~30 semitones
      const base = 220;
      const step = Math.floor(scaled % pentatonic.length);
      const octave = Math.floor(scaled / pentatonic.length);
      return base * Math.pow(2, octave) * Math.pow(2, pentatonic[step]/12);
    }

    function xToCutoff(x) {
      const width = window.innerWidth;
      const norm = x / width;
      return 200 + norm * 5000; // cutoff range
    }

    function startVoice(id, x, y) {
      if (Object.keys(voices).length >= 3) return; // limit to 3 voices
      initAudio();
      if (voices[id]) return;

      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();

      osc.type = currentWaveform;
      filter.type = "lowpass";
      gain.gain.setValueAtTime(0.2, audioContext.currentTime);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);

      osc.start();

      voices[id] = { osc, gain, filter };
      updateVoice(id, x, y);
    }

    function updateVoice(id, x, y) {
      const v = voices[id];
      if (!v) return;
      v.osc.frequency.setValueAtTime(yToFreq(y), audioContext.currentTime);
      v.filter.frequency.setValueAtTime(xToCutoff(x), audioContext.currentTime);
    }

    function stopVoice(id) {
      const v = voices[id];
      if (!v) return;
      v.gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
      v.osc.stop(audioContext.currentTime + 0.3);
      delete voices[id];
    }

    // === Mouse control (single voice) ===
    let mouseDown = false;
    window.addEventListener("mousedown", e => {
      mouseDown = true;
      startVoice("mouse", e.clientX, e.clientY);
    });
    window.addEventListener("mousemove", e => {
      if (mouseDown) updateVoice("mouse", e.clientX, e.clientY);
    });
    window.addEventListener("mouseup", () => {
      mouseDown = false;
      stopVoice("mouse");
    });

    // === Touch control (multi-touch up to 3) ===
    window.addEventListener("touchstart", e => {
      for (let t of e.changedTouches) {
        startVoice(t.identifier, t.clientX, t.clientY);
      }
    });
    window.addEventListener("touchmove", e => {
      for (let t of e.changedTouches) {
        updateVoice(t.identifier, t.clientX, t.clientY);
      }
    });
    window.addEventListener("touchend", e => {
      for (let t of e.changedTouches) stopVoice(t.identifier);
    });
    window.addEventListener("touchcancel", e => {
      for (let t of e.changedTouches) stopVoice(t.identifier);
    });

    // === Feed simulation (no sounds) ===
    const feed = document.getElementById("feed");
    let postCount = 0;
    function addPost() {
      postCount++;
      const post = document.createElement("div");
      post.className = "post";
      post.innerHTML = `
        <img src="https://picsum.photos/600/400?random=${postCount}" alt="Random">
        <div class="actions">
          <button class="action-btn like-btn">‚ù§Ô∏è</button>
          <button class="action-btn comment-btn">üí¨</button>
          <button class="action-btn share-btn">üì§</button>
        </div>`;
      feed.appendChild(post);
      assignButtonWaveforms(post);
    }

    function loadInitialPosts() {
      for (let i = 0; i < 5; i++) addPost();
    }

    window.addEventListener("scroll", () => {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 100) {
        addPost();
      }
    });

    // === Waveform assignment ===
    function assignButtonWaveforms(scope=document) {
      scope.querySelectorAll(".like-btn").forEach(btn => {
        btn.addEventListener("click", () => { currentWaveform = "sine"; });
      });
      scope.querySelectorAll(".comment-btn").forEach(btn => {
        btn.addEventListener("click", () => { currentWaveform = "square"; });
      });
      scope.querySelectorAll(".share-btn").forEach(btn => {
        btn.addEventListener("click", () => { currentWaveform = "triangle"; });
      });
    }

    window.addEventListener("DOMContentLoaded", () => {
      loadInitialPosts();
    });
  </script>
</body>
</html>
